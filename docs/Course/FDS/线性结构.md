# 线性表&栈&队列

## 线性表 | Lists

### 线性表的抽象数据类型描述

1.  `类型名称` : 线性表 | List
2.  `数据对象集` :  线性表是n( $\ge$ 20)个元素构成的有序序列
3.  `操作集` : 线性表 L $\epsilon$ List，整数 i 表示位置，元素 X $\epsilon$ ElementType.

### 线性表的顺序存储实现

#### 线性表的数组存储实现

* 主要操作实现

??? example "初始化(建立空的顺序表)"
    ```c
    List MakeEmpty()
    {
        List Ptrl;
        Ptrl = (List)malloc(sizeof(struct LNode));
        Ptrl->Last = -1;
        return Ptrl;
    }
    ```

??? example "查找"
    ```c
    int Find(ElementType X, List Ptrl)
    {
        int i = 0;
        while(i <= Ptrl->Last && Ptrl->Data[i] != X)
        {
            i++;
        }
        if(i > Ptrl->Last)
            return -1;
        else
            return i;
    }
    ```

??? example "在第i(1 <= i <= n+1)个位置上插入新元素X"
    ```c
    void Insert(ElementType X, int i, List L)
    {
        int j;
        if(Ptrl->Last == MAXSIZE-1)
        {
            printf("表满");
            return ;
        }
        if(i < 1 || i > Ptrl->Last+2 )
        {
            printf("位置不合法");
            return;
        }
        for(j = Ptrl->Last; j >= i - 1; j--)
        {
            Ptrl->Data[j+1] = Ptrl->Data[j];
        }
        Ptrl->Data[i-1] = X;
        Ptrl->Last++;
        return;   
    }
    ```

??? example "删除"
    ```c
    void Delete( int i, List Ptrl )
    {
        int j;
        if(i < 1 || i > Ptrl->Last+1)
        {
            printf("不存在");
            return;
        }
        for(j = i; i <= Ptrl->Last; j++)
        {
            Ptrl->Data[j-1] = Ptrl->Data[j];
        }
        Ptrl->Last--;
        return E;
    }
    ```

#### 线性表的链表存储实现

* 不要求逻辑上相邻的两个元素在物理上也相邻
* 通过修改”链“建立起数据元素之间逻辑关系

!!! tip
	插入、删除不需要移动数据元素，只需要修改”链“

??? example “链表结构”
    ```c
    typedef struct LNode *List;
    struct LNode{
        ElementType Data;
        List Next;
    };
    struct LNode L;
    List Ptrl;
    ```

* 主要操作:

??? example "求表长"
    ```c
    int Length(List Ptrl)
    {
        List p = Ptrl;
        int j = 0;
        while(p)
        {
            p = p->Next;
            j ++;
        }
        return j;
    }
    ```

??? example "查找"
    ```c
    /*（1）按序号查找*/
    List FindKth(int K, List Ptrl)
    {
    List p = Ptrl;
        while(p != NULL && i < k)
        {
            p = p->Next;
            i++;
        }
        if(i == K)
            return p;
        else
            return NULL;
    }
    /*（2）按值查找*/
    List Find(ElementType X, List Ptrl)
    {
        List p = Ptrl;
        while(p != NULL && p->Data != X)
        {
            p = p->Next;
        }
        return p;
    }
    ```

??? example "在第i-1(1 <= i <= n+1)个结点后插入一个值为X的新结点"
    ```c
    List Insert(ElementType X, List Ptrl)
    {
        List p, s;
        if(i == 1)
        {
            s = (List)malloc(sizeof(struct LNode));
            s->Data = X;
            s->Next = Ptrl;
            return s;
        }
        p = Findkth(i-1, Ptrl);
        if(p == NULL)
        {
            printf("参数i错误");
            return NULL;
        }
        else
        {
            s = (List)malloc(sizeof(struct LNode));
            s->Data = X;
            s->Next = p->Next;
            p->Next = s;
            return Ptrl;
        }
    }
    ```

??? example "删除第i个结点（1 <= i <= n）"
    ```c
    List Delete(int i, List Ptrl)
    {
        List p, s;
        if(i == 1)
        {
            s = Ptrl;
            if( Ptrl != NULL)
                Ptrl = Ptrl->Next;
            else
                return NULL;
            free(s);
            return Ptrl;
        }
        p = FindKth(i-1, Ptrl);
        if( p == NULL)
        {
            printf("第%d个结点不存在"，i-1);
            return NULL;
        }
        else if(p->Next == NULL)
        {
            printf("第%d个结点不存在"，i);
            return NULL;
        }
        else
        {
            s = p->Next;
            p->Next = s->Next;
            free(s);
            return Ptrl;
            
        }
    }
    ```

### 广义表

* 广义表是线性表的推广
* 对于线性表来说，n 个元素都是基本的单元素
* 广义表中，这些元素不仅可以是单元素还可以是另一个广义表

??? example "广义表结构"
    ```c
    typedef struct GNode *Glist;
    struct GNode{
        int Tag;    /* 标志域，0表示结点是单元素，1表示是广义表*/
        union{      /* 子表指针域Sublist与单元素数据域Data复用，即共用存储空间*/
            ElementType Data;
            GList SubList;
        }URegion;
        GList Next; /* 指向后继结点 */
    }
    ```

## 栈 | Stacks



## 队列 | Queues

